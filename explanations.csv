Result,Explanation
Dynamic Priority MLQ, Tasks are grouped into categories and reprioritized frequently based on urgency or deadlines. This allows flexibility in handling new or changing priorities. This algorithm dynamically adjusts task prioritisation by combining priorities with category-based weights and deadlines. Tasks are sorted by priority with higher-priority tasks scheduled first. If two tasks share the same priority deadlines are used as tie-breakers ensuring earlier deadlines are addressed first. Each task duration is converted from hours to minutes and tasks are sequentially scheduled updating the current time for subsequent tasks. This ensures a balance between flexibility and urgency adapting to changes in task priorities while optimising the study schedule.
Static Priority MLQ, This algorithm organises tasks into fixed categories based on predefined priorities with higher-priority categories scheduled first. Within each priority category tasks are sorted using Shortest Job First logic ensuring shorter tasks are completed before longer ones. Each tasks duration is converted from hours to minutes and tasks are sequentially scheduled updating the current time as each task is completed. This rigid structure maintains consistency and predictability in task execution providing a straightforward and disciplined approach to study scheduling without any dynamic adjustments.
Strict Time-Slice RR, Equal time (quantum) is allocated to each task or subject ensuring fairness but without exceptions. This algorithm ensures that equal time slices are allocated to each task or subject using a strict Round-Robin approach. Tasks are processed in a FIFO order with each task receiving a fixed quantum time for execution. If a tasks remaining duration exceeds the allocated quantum time it is paused and re-added to the queue for subsequent cycles. Task durations are converted from hours to minutes ensuring precise scheduling and the current time is updated after each task execution. This method prioritises fairness across all tasks by distributing study time evenly without exceptions making it ideal for balancing attention across multiple topics or subjects.
No Workflow, Tasks are done randomly without a structured plan often leading to confusion and inefficiency. This algorithm processes tasks sequentially without applying any form of prioritisation or structured workflow. This straightforward approach lacks prioritisation or adaptive logic making it suitable for scenarios where tasks can be handled in a linear and unstructured manner. 
Dynamic RR, Tasks are cycled through but time allocation changes dynamically based on complexity or progress. Tasks are executed in a cyclical manner with each receiving time proportional to its category weight. If a tasks remaining duration exceeds its allocated quantum it is partially completed updated and re-queued. The scheduling ensures fairness while accommodating variations in task complexity and importance making it suitable for study methods that prioritize diverse subject areas and adapt quantum time dynamically to task significance.
Dynamic Weighted FCFS, Tasks are handled in the order they arrive but weights are assigned based on priority or importance. Tasks are sorted in descending order of category weights ensuring higher-weighted tasks are prioritized. The duration of each task is converted to minutes and adjusted inversely proportional to its weight ensuring tasks with higher perceived effort take less adjusted time. Tasks are then scheduled sequentially with their start and end times calculated and the current time updated accordingly. This approach prioritizes tasks based on their significance or difficulty providing a structured yet adaptable method to manage workloads effectively.
Static FCFS,This algorithm schedules tasks using a static first-come first-serve approach ensuring tasks are processed in the order they are provided without any prioritization or adjustments. 
Dynamic Weighted SJF,Shorter tasks are prioritized but adjustments are made dynamically as new tasks are added or task durations change.
FCFS with Priority Overrides,This algorithm schedules tasks by considering their start times priorities and deadlines in a hierarchical manner. Tasks are first sorted by their start times with earlier tasks scheduled first. If two tasks share the same start time their priority values are compared with higher-priority tasks scheduled earlier. For tasks with equal start times and priorities deadlines serve as the final tiebreaker ensuring tasks with the earliest deadlines are addressed first. Tasks are sequentially scheduled updating the current time as each task is completed. This approach balances fairness with urgency ensuring that higher-priority and time-sensitive tasks are completed promptly while maintaining a structured and organized schedule.
Static Weighted SJF,Tasks are sorted by their adjusted durations calculated by dividing the original duration by the category weight. In cases where two tasks have the same adjusted duration their “Date Set” serves as a tiebreaker prioritizing earlier dates. Each task is scheduled sequentially with start and end times updated as tasks are completed. This approach ensures efficient task scheduling by balancing category importance with task duration optimizing task completion based on predefined priorities.
Dynamic Priority,This algorithm dynamically schedules tasks by considering various preemption rules to prioritize task execution. Tasks are first sorted by their arrival times to ensure they are processed in the correct sequence. Each tasks remaining duration is initialized or retained for accurate tracking. As time progresses tasks are enqueued into a task queue when their start time is reached. The queue is sorted dynamically based on the selected preemption rule which could prioritize higher-priority tasks shorter tasks lower-effort tasks or tasks with imminent deadlines. If a task with a higher priority arrives it preempts the currently running task which is re-queued for later execution. Tasks are processed sequentially with their remaining duration reduced at each step and completed tasks removed from the queue. This approach ensures adaptability to changing priorities while optimizing task scheduling based on user-defined rules.
Static Priority,Tasks are ranked by importance and you stick to this fixed ranking until all are completed. They are sorted in descending order based on their priority values provided by the user. Each task is then scheduled sequentially with its start and end times calculated based on the current time. Once a task is completed the current time is updated to reflect the tasks completion before moving on to the next task in the list. This approach ensures a structured and predictable execution of tasks aligning with predefined priorities but does not allow for dynamic adjustments or changes in task order after the initial sorting.
MLQ with reprioritisation,This algorithm organizes tasks into three priority queues—high medium and low—based on the your provided priority levels. Tasks are initially categorized into their respective queues and then sorted within each queue by duration if the preemption rule is “Higher priority Tasks.” If the rule is “Shorter Tasks” tasks across all queues are globally sorted by duration and then reallocated into their priority queues. The algorithm processes tasks queue by queue beginning with the highest-priority queue and moving downward ensuring that higher-priority tasks are always completed before lower-priority ones. This method combines structured prioritization with flexible task ordering based on user-defined rules balancing urgency and efficiency.
Preemptive SJF,asks are sorted by their arrival times and added to a queue upon arrival. The queue is then reordered based on the chosen rule such as “Shorter Tasks” (tasks with the shortest remaining duration are prioritized) “Higher priority Tasks” (tasks with higher priority take precedence) “Lower Effort Tasks” (tasks requiring less effort are prioritized) or “Tasks with imminent deadlines” (tasks with earlier deadlines are prioritized). If a task with higher priority becomes available the currently running task is paused and added back to the queue. Tasks are executed one unit of time at a time continuously checking for preemption or task completion. This approach ensures flexibility and responsiveness dynamically adapting to changing conditions while prioritizing the most critical tasks.
Hybrid Priority MLQ, This algorithm combines features of Multi-Level Queue and priority-based scheduling organizing tasks into three priority queues high medium and low based on user-defined priority levels. Within each queue tasks are sorted dynamically according to the selected preemption rule. For example “Shorter Tasks” prioritizes tasks with shorter durations “Higher Priority Tasks” sorts tasks strictly by priority and “Tasks with Imminent Deadlines” ensures tasks with earlier deadlines are executed first. Tasks are processed sequentially within each queue starting with the highest-priority queue and working downward. This hybrid approach balances urgency with adaptability ensuring critical tasks are addressed promptly while maintaining a flexible structure that accommodates varying scheduling needs.
Static Priority with FCFS,Tasks are first sorted by their priority level with higher-priority tasks processed before lower-priority ones. If two tasks share the same priority the order is determined by their date set ensuring tasks created earlier are addressed first. Each task is scheduled sequentially from the current time maintaining the order established by the sorting process. This method ensures that important tasks are prioritized while respecting the chronological order of task creation providing a balance between urgency and fairness.
Static Priority with SJF,Tasks are grouped into priority levels with higher-priority tasks addressed before lower-priority ones. Within each priority level tasks are sorted by duration so shorter tasks are completed first. The scheduling process begins with the highest-priority queue and moves sequentially through the lower-priority queues. Each task is executed in the order determined by its priority and duration optimizing for efficiency while ensuring that more urgent tasks are handled first.
Pre-assigned Fixed RR,  Tasks are initialized with their remaining durations and processed in a cyclic order from a queue. Each task is allocated a fixed quantum of execution time and tasks that are not completed within their allocated time are updated with the remaining duration and re-enqueued for further execution. The process repeats until all tasks are fully executed providing a balanced approach to task scheduling while ensuring that no single task takes up all the available time.
General Fixed RR,Tasks are initialized with their remaining durations and added to a queue. Each task is processed in sequence and if it cannot be fully completed within its allocated quantum its remaining duration is updated and it is re-enqueued for another cycle. This ensures fairness by distributing execution time evenly across all tasks while maintaining a predictable scheduling structure making it suitable for scenarios requiring balanced time allocation without prioritization.
Size Adaptive RR, Each task is assigned a weight derived from its category which modifies the quantum time allocated to it. Tasks are processed in a cyclic manner and if a task cannot be completed within its adjusted quantum it is re-enqueued with its remaining duration updated. This adaptive method ensures that tasks from higher-weight categories receive proportionally more time balancing fairness with the complexity or importance of tasks making it ideal for scenarios where task categorization influences execution priorities.
Deadline Adaptive RR, Tasks are sorted by deadline initially and each is allocated a quantum of time to execute. If a task cannot be completed within its allocated quantum its remaining duration is updated and it is re-enqueued while maintaining the deadline-based order. This ensures that tasks with earlier deadlines receive higher priority in subsequent cycles. The method balances fairness with time sensitivity making it suitable for scenarios where respecting deadlines is critical while maintaining equitable task execution.
Static Weighted MLQ, This algorithm assigns tasks to three static priority queues—high medium and low—based on their priority levels provided by the user. Within each priority queue tasks are sorted by their weighted durations calculated by dividing the task duration by a category weight. The weight for each category is predefined in a slots array and adjusts the tasks duration according to its category. Tasks are then scheduled queue by queue beginning with the highest-priority queue. This ensures that higher-priority tasks are handled first while the weighted duration calculation allows for nuanced prioritization based on task characteristics balancing both urgency and complexity.
Dynamic MLQ,asks are processed sequentially from the highest-priority queue to the lowest with each task being assigned a start and end time based on its duration and the current system time. This method ensures that tasks are not only prioritized by importance but are also scheduled in a way that respects their deadlines creating a balance between urgency and efficiency.